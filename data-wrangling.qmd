---
title: 'Data Wrangling'
author: 'Briana Barajas'
date: 2024-01-23
---

## Preparation

Set-up

```{r, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

Load packages

```{r, results='hide'}
# wrangling
library(tidyverse)
library(here)
library(janitor)

# raster/geospatial
library(sf)
library(ggspatial)
library(terra)
library(spatialEco) #transform elev to hli

# modeling
library(dismo)
```

## Read in Data

### Species occurence data

```{r occurence, results='hide'}
# read data
occurence <- st_read(here('data/CampRoberts_spatial_data/Species_pts/CR_BASP_obs_11Jul22.shp')) %>% 
  clean_names() %>% 
  st_make_valid()

# reproject (using "WGS84")
occurence <- st_transform(occurence, crs = "WGS84")
```

```{r, eval=FALSE}
# map point data
ggplot(data = occurence) +
  geom_sf()
```

### Plot outlines

```{r plt outline, message=FALSE, warning=FALSE, results='hide'}
# create list of plot outline shape files
plot_outline_files <- list.files(here('data', 'CampRoberts_spatial_data', 'plot_outlines'), pattern = "\\.shp$", full.names = TRUE)

# for-loop to read in data
for (i in seq_along(plot_outline_files)) {
  
  # read in data
  outline <- st_read(plot_outline_files[i]) %>% 
    st_make_valid()
  
  # update CRS
  outline <- st_transform(outline, crs = "WGS84")
  
  # save to global environment
  assign(paste0("outline_p", i), outline, envir = .GlobalEnv)
  
}

# join all outlines into a single sf layer
plot_outlines <- rbind(outline_p1, outline_p2, outline_p3, outline_p4,
              outline_p5, outline_p6, outline_p7, outline_p8)

# remove temporary variables
rm(outline, plot_outline_files, outline_p1, 
   outline_p2, outline_p3, outline_p4,outline_p5, 
   outline_p6, outline_p7, outline_p8)
```

```{r, eval=FALSE}
# plot all plot outlines
ggplot(plot_outlines) +
  geom_sf()
```

#### Points within plots

Check if the `occurence` points fall within the `plot_outlines` using `st_filter.`

```{r subset}
# compare to total occurence
glue::glue("Number of total occurence points: {nrow(occurence)}")

# Run st_filer to get points that touch the outlines
glue::glue("Number of occurence points within plot outlines: {nrow(st_filter(occurence, plot_outlines, .predicate = st_intersects))}")

# create subset of occurences that fall within/intersect with plots
occurence_subset <- st_filter(occurence, plot_outlines,
                              .predicate = st_intersects)
```

### Environment data

```{r env read, warning=FALSE}
# read in data files
slope <- rast(x = 'data/CampRoberts_spatial_data/crob_slope')
elev <- rast('data/CampRoberts_spatial_data/crob_elev')

# reproject raster data
elev <- project(elev, y = "WGS84")
slope <- project(slope, y = "WGS84")
```

```{r, eval=FALSE}
# plot data
plot(slope, main = 'Slope Raster')
plot(elev, main = 'Elevation Raster')
```

#### Transforming Aspect

Aspect currently ranges from 0 to 360 degrees (view plot scale). This can impact model performance since 1 degree is adjacent to 360 degrees, but a model will recognize these values as being very different. The Beers method (1996) rescales aspect to range between 0 and 1, but does not consider the steepness of slope. The McCune & Keon method (2002) works very similarly, but uses slope and aspect as indicators of a **heat load index. For this method, HLI values range from 0 (coolest) to 1 (hottest).**

Similary, the Roberts & Cooper method (1989) transforms aspect to a value between 0 and 1. A value of 0 responds to land oriented in the north-east direction, while 1 represents the dyer, south-southwestern slopes. Since this method still uses directionality, I decided to use th McCune & Keon method. The McCune method can potentially produce a better analysis of micro-climates that a salamander might be more sensitive to.

```{r hli, message=FALSE}
# convert elev raster into heat load index (hli)
hli <- hli(elev)
```

```{r, eval=FALSE}
# plot hli raster
plot(hli, main = 'Heat Load Index Raster')
```

### Canopy rasters

Unlike the environmental data, canopy information is specific to the plots.

```{r, warning=FALSE}
# create a list of canopy file path
canopy_files <- list.files(here('data', 'CampRoberts_spatial_data', 'Canopy_raster'), pattern = 'can*', full.names = TRUE)

# for-loop reads in canopy rasters & save them to the Global environment
for (i in seq_along(canopy_files)) {
  
  # read in canopy raster
  can <- rast(canopy_files[i])
  
  # reproject raster
  can <- project(x = can, y = "WGS84")
  
  # save the updated raster
  assign(paste0("can_p", i), can, envir = .GlobalEnv)
}

# remove duplicate of last raster read in (can_rast_p8)
rm(can, canopy_files)
```

```{r}
# plot one canopy raster to check
plot(can_p3, main = "Canopy Plot 3")
```

### Brush Variables

Only three of the brush variables available are being used. This includes downed wood cover percent (`dnd_dn`), litter cover percentage (`li_dn`), and grass cover (`gs_dn`). Similar to the canopy data, these brush variables are unique to each plot.

#### Downed wood cover percent

```{r}
# create a list of dnd_dn files
dnd_files <- list.files(here('data', 'CampRoberts_spatial_data', 'brush_IDW3rad'),
                           pattern = '*dnd_dn_p.$', full.names = TRUE)

# for-loop reads in canopy rasters & saves to global environment
for (i in seq_along(dnd_files)) {
  
  # read in canopy raster
  dnd_rast <- rast(dnd_files[i])
  
  # reproject raster
  dnd_rast <- project(x = dnd_rast, y = "WGS84")
  
  # save the updated raster
  assign(paste0("dnd_p", i), dnd_rast, envir = .GlobalEnv)
}

# remove extra layer in environment
rm(dnd_rast, dnd_files)
```

```{r}
# plot one raster to chek
plot(dnd_p3)
```


#### Litter cover percentage

```{r}
# create a list of dnd_dn files
litter_files <- list.files(here('data', 'CampRoberts_spatial_data', 'brush_IDW3rad'),
                           pattern = '3rd_li_dn_p.$', full.names = TRUE)

# for-loop reads in canopy rasters & saves to global environment
for (i in seq_along(litter_files)) {
  
  # read in canopy raster
  litter_rast <- rast(litter_files[i])
  
  # reproject raster
  litter_rast <- project(x = litter_rast, y = "WGS84")
  
  # save the updated raster
  assign(paste0("litter_p", i), litter_rast, envir = .GlobalEnv)
}

# remove extra layer in environment
rm(litter_files, litter_rast)
```

```{r}
# plot one raster to check projection
plot(litter_p3)
```

