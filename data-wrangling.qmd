---
title: 'Data Wrangling'
author: 'Briana Barajas'
date: 2024-01-23
---

## Preparation

Set-up

```{r, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

Load packages

```{r, results='hide'}
# wrangling
library(tidyverse)
library(here)
library(janitor)

# raster/geospatial
library(sf)
library(tmap)
library(terra)
library(spatialEco) #transform elev to hli

# modeling
library(dismo)
```

## Read in Data

### Species occurence data

```{r occurence, results='hide'}
# read data
occurence <- st_read(here('data/CampRoberts_spatial_data/Species_pts/CR_BASP_obs_11Jul22.shp')) %>% 
  clean_names() %>% 
  st_make_valid()

# reproject (using "WGS84")
occurence <- st_transform(occurence, crs = "WGS84")
```

```{r, eval=FALSE}
# map point data
ggplot(data = occurence) +
  geom_sf()
```

### Plot outlines

```{r plt outline, message=FALSE, warning=FALSE, results='hide'}
# create list of plot outline shape files
plot_outline_files <- list.files(here('data', 'CampRoberts_spatial_data', 'plot_outlines'), pattern = "\\.shp$", full.names = TRUE)

# for-loop to read in data
for (i in seq_along(plot_outline_files)) {
  
  # read in data
  outline <- st_read(plot_outline_files[i]) %>% 
    st_make_valid()
  
  # update CRS
  outline <- st_transform(outline, crs = "WGS84")
  
  # save to global environment
  assign(paste0("outline_p", i), outline, envir = .GlobalEnv)
  
}

# join all outlines into a single sf layer
plot_outlines <- rbind(outline_p1, outline_p2, outline_p3, outline_p4,
              outline_p5, outline_p6, outline_p7, outline_p8)

# remove temporary variables
rm(outline, plot_outline_files, outline_p1, 
   outline_p2, outline_p3, outline_p4,outline_p5, 
   outline_p6, outline_p7, outline_p8)
```

```{r, eval=FALSE}
# plot all plot outlines
ggplot(plot_outlines) +
  geom_sf()
```

#### Points within plots

Check if the `occurence` points fall within the `plot_outlines` using `st_filter.`

```{r subset}
# compare to total occurence
glue::glue("Number of total occurence points: {nrow(occurence)}")

# Run st_filer to get points that touch the outlines
glue::glue("Number of occurence points within plot outlines: {nrow(st_filter(occurence, plot_outlines, .predicate = st_intersects))}")

# create subset of occurences that fall within/intersect with plots
occurence_subset <- st_filter(occurence, plot_outlines,
                              .predicate = st_intersects)
```

### Environment data

```{r env read, warning=FALSE}
# read in data files
slope <- rast(x = 'data/CampRoberts_spatial_data/crob_slope')
elev <- rast('data/CampRoberts_spatial_data/crob_elev')

# reproject raster data
elev <- project(elev, y = "WGS84")
slope <- project(slope, y = "WGS84")
```

```{r, eval=FALSE}
# plot data
plot(slope, main = 'Slope Raster')
plot(elev, main = 'Elevation Raster')
```

#### Transforming Aspect

Aspect currently ranges from 0 to 360 degrees (view plot scale). This can impact model performance since 1 degree is adjacent to 360 degrees, but a model will recognize these values as being very different. The Beers method (1996) rescales aspect to range between 0 and 1, but does not consider the steepness of slope. The McCune & Keon method (2002) works very similarly, but uses slope and aspect as indicators of a **heat load index. For this method, HLI values range from 0 (coolest) to 1 (hottest).**

Similary, the Roberts & Cooper method (1989) transforms aspect to a value between 0 and 1. A value of 0 responds to land oriented in the north-east direction, while 1 represents the dyer, south-southwestern slopes. Since this method still uses directionality, I decided to use th McCune & Keon method. The McCune method can potentially produce a better analysis of micro-climates that a salamander might be more sensitive to.

```{r hli, message=FALSE}
# convert elev raster into heat load index (hli)
hli <- hli(elev)
```

```{r, eval=FALSE}
# plot hli raster
plot(hli, main = 'Heat Load Index Raster')
```

### Canopy rasters

Unlike the environmental data, canopy information is specific to the plots.

```{r, warning=FALSE}
# create a list of canopy file path
canopy_files <- list.files(here('data', 'CampRoberts_spatial_data', 'Canopy_raster'), pattern = 'can*', full.names = TRUE)

# for-loop reads in canopy rasters & save them to the Global environment
for (i in seq_along(canopy_files)) {
  
  # read in canopy raster
  can <- rast(canopy_files[i])
  
  # reproject raster
  can <- project(x = can, y = "WGS84")
  
  # save the updated raster
  assign(paste0("can_p", i), can, envir = .GlobalEnv)
}

# remove duplicate of last raster read in (can_rast_p8)
rm(can, canopy_files)
```

```{r}
# plot one canopy raster to check
plot(can_p3, main = "Canopy Plot 3")
```

### Brush Variables

Only three of the brush variables available are being used. This includes downed wood cover percent (`dnd_dn`), litter cover percentage (`li_dn`), and grass cover (`gs_dn`). Similar to the canopy data, these brush variables are unique to each plot.

#### Downed wood cover percent

```{r}
# create a list of dnd_dn files
dnd_files <- list.files(here('data', 'CampRoberts_spatial_data', 'brush_IDW3rad'),
                           pattern = '3rd_dnd_dn_p.$', full.names = TRUE)

# for-loop reads in downed wood rasters & saves to global environment
for (i in seq_along(dnd_files)) {
  
  # read in canopy raster
  dnd_rast <- rast(dnd_files[i])
  
  # reproject raster
  dnd_rast <- project(x = dnd_rast, y = "WGS84")
  
  # save the updated raster
  assign(paste0("dnd_p", i), dnd_rast, envir = .GlobalEnv)
}

# remove extra layer in environment
rm(dnd_rast, dnd_files)
```

```{r}
# plot one raster to chek
plot(dnd_p3)
```


#### Litter cover percentage

```{r}
# create a list of dnd_dn files
litter_files <- list.files(here('data', 'CampRoberts_spatial_data', 'brush_IDW3rad'),
                           pattern = '3rd_li_dn_p.$', full.names = TRUE)

# for-loop reads in litter rasters & saves to global environment
for (i in seq_along(litter_files)) {
  
  # read in canopy raster
  litter_rast <- rast(litter_files[i])
  
  # reproject raster
  litter_rast <- project(x = litter_rast, y = "WGS84")
  
  # save the updated raster
  assign(paste0("litter_p", i), litter_rast, envir = .GlobalEnv)
}

# remove extra layer in environment
rm(litter_files, litter_rast)
```

```{r}
# plot one raster to check projection
plot(litter_p3)
```

#### Grass cover
```{r, eval=FALSE}
# create a list of grass cover files
grass_files <- list.files(here('data', 'CampRoberts_spatial_data', 'brush_IDW3rad'),
                          pattern = '3rd_gs_dn_p.$', full.names = TRUE)

# 



# for-loop reads in canopy rasters & saves to global environment
for (i in seq_along(litter_files)) {
  
  # read in canopy raster
  litter_rast <- rast(litter_files[i])
  
  # reproject raster
  litter_rast <- project(x = litter_rast, y = "WGS84")
  
  # save the updated raster
  assign(paste0("litter_p", i), litter_rast, envir = .GlobalEnv)
}

# remove extra layer in environment
rm(litter_files, litter_rast)
```


# Scratch
Merge test
```{r merge_test, eval=FALSE}
canopy_full <- terra::merge(can_p1, can_p2, can_p3,
                            can_p4, can_p5, can_p6,
                            can_p7, can_p8)

glue::glue("Canopy_p1 resolution: {res(can_p1)}
           Canopy_p2 resolution: {res(can_p2)}
           Canopy_p3 resolution: {res(can_p3)}
           Canopy_p4 resolution: {res(can_p4)}")

can_p1_resamp <- resample(can_p1, can_p2)
res(can_p1_resamp) == res(can_p2)

test_merge <- terra::merge(can_p1_resamp, can_p2)

plot(test_merge, main = "Merge plot 1 and 2")
plot(can_p1, main = "Plot 1 Canopy")
plot(can_p1_resamp, main = "Resampled Plot 1 Canopy")
plot(can_p2, main = "Plot 2 canopy")

test_merge2 <- c(can_p1_resamp, can_p2)
ext(test_merge) > ext(can_p1_resamp)

test_merge3 <- mosaic(can_p1_resamp, can_p2)
plot(test_merge3)
```

function w/for-loop test
```{r, eval=FALSE}

# Create a function that takes in a file list of rasters from plot 1-8, to reproject and combine them into a single raster
combine_plot_raster <- function(raster_files, select_crs, select_extent){
  
  # create an empty raster template
  raster_template <- rast(extent, vals = NA, crs = select_crs)
  min_res <- Inf
  
  # read in all files
  for(i in seq_along(raster_files)){
    
    # read in rasters individually
    env_rast <- terra::rast(raster_files[i])
    
    # re-project raster
    env_rast <- terra::project(x = env_rast, y = select_crs)
    
    # update resolution to minimum resolution for individual rasters
    min_res <- min(min_res, res(env_rast)[1], res(env_rast)[2])
    
    # fill template raster w/transformed rasters
    raster_template <- rast(env_rast, raster_template)
    
  } # END for-loop
  
}

# Error in methods::as(x, "SpatRaster") :
# no method or default for coercing “standardGeneric” to “SpatRaster”

```


template raster test
```{r, eval=FALSE}
# create a template raster using the extent from plot_outlines
e <- ext(-121, -120, 35, 36)
template <- rast(e)
template <- project(template, y = "WGS84")

# update to lower resolution (can_p3 in this example)
res(can_p1) <- res(can_p3)
res(template) <- res(can_p3)
res(can_p2) <- res(can_p3)

# merge canopy rasters for plot 3 and 1 to the template
test_merge <- merge(template, can_p1, can_p3, can_p2)

plot(test_merge)
```


```{r, eval = FALSE}
tm_shape(plot_outlines) +
  tm_polygons() +
  tm_shape(can_p1) +
  tm_raster() +
  tm_shape(can_p2) +
  tm_raster() +
  tm_shape(can_p3) +
  tm_raster() +
  tm_shape(can_p4) +
  tm_raster() +
  tm_shape(can_p5) +
  tm_raster() +
  tm_shape(can_p6) +
  tm_raster() +
  tm_shape(can_p7) +
  tm_raster() +
  tm_shape(can_p8) +
  tm_raster()
```


# Maxent - Plot 1
```{r}
## ========================================
##            Read in Data             ----
## ========================================

# species point data
occurence_plt1 <- st_read(here('data/CampRoberts_spatial_data/Species_pts/CR_BASP_obs_11Jul22.shp')) %>% 
  clean_names() %>% 
  st_make_valid() %>% 
  filter(plot == 1)

# 
```

