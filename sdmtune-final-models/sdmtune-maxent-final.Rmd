---
title: "Final MaxEnt Predictions Using SDMTune"
author: "Briana Barajas"
date: 2024-04-17
---

## Preparation

Rasters were pre-processed and saved so they could easily be loaded, and combined into a raster stack of the appropriate data type. `SDMTune` provides functionality for reducing the number of environmental background variables included in a species distribution model. Instead of pre-selecting environmental variables, all variables were included to determine differences between plots.

__Load Data and Packages:__
```{r, include = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r, results='hide'}
# wrangling
library(tidyverse)
library(here)
library(janitor)

# raster/geospatial
library(sf)
library(tmap)
library(terra)

# modeling
library(SDMtune)
library(rsample)
library(rJava)

# set data directory
output_dir <- here("data", "updated-rasters")
data_dir <- here("data", "CampRoberts_spatial_data")

# set plot number
plot_name <- "plot1"
plot_number <- 1
```

```{r}
# load occurrence points
occurrences <- st_read(here(data_dir, "Species_pts", "CR_BASP_obs_11Jul22.shp")) %>% 
  st_make_valid() %>% 
  clean_names() %>% 
  filter(plot == plot_number)

# list all environmental rasters
env_layer_names <- c("ba_dn", "br_ht","dnd_db", "dnd_st", "elev", "gs_dn", 
                     "li_dn", "slope", "br_dn", "canopy","dnd_dn", 
                     "dnd_stc", "fb_dn", "hli", "rk_dn")

# load environmental layers
for (i in env_layer_names) {
  layer <- rast(here(output_dir, i, plot_name, paste0(i, ".asc")))
  assign(x = paste0(i), layer, envir = .GlobalEnv)
}

# create raster stack
predictor_stack_rast <- c(ba_dn, br_ht, dnd_st, elev, gs_dn, li_dn,
                          slope, br_dn, canopy, dnd_dn, dnd_stc, dnd_db,
                          fb_dn, hli, rk_dn)

rm(ba_dn, br_ht, dnd_st, elev, gs_dn, li_dn, slope, br_dn, canopy, dnd_dn, 
   dnd_stc, fb_dn, hli, rk_dn, layer, dnd_db)
```

## Data Preparation
```{r}
set.seed(124)

# update df, isolating occurrence lat and long
occurrence_coords <- occurrences %>% 
  st_drop_geometry() %>% 
  rename(y = latitude,
         x = longitude) %>% 
  dplyr::select(x,y)

# create background points using raster stack
bg_points <- spatSample(predictor_stack_rast,
                        size = 1000,
                        replace = TRUE,
                        xy = TRUE)

# isolate coordinates of bg points
bg_coords <- bg_points %>% dplyr::select(c(x,y))

```
There seems to be a large discrepancy in model performance depending on the number of background points. Existing research does not appear to support any single solution for selecting the number of background, especially with such a small spatial scale. Moving forward, background points might be changed to be related to occurence points (i.e. 100 * occurrences). This would allow the model to fluctuate for each plot, since they greatly vary in the number of occurrences. 

### Pre-Processing
```{r}
# create SWD object using data
swd_obj <- prepareSWD(species = "Black-bellied Slender Salamander",
                      p = occurrence_coords, # occurrence points
                      a = bg_coords, # background point coordinates
                      env = predictor_stack_rast) # background layers

# update swd_object to add sample to background
swd_obj <- addSamplesToBg(swd_obj)

# split data into test and train
split <- trainValTest(swd_obj, 
                      test = 0.2, # % of data for testing
                      val = 0, # % of of data for validation
                      only_presence = TRUE, # F=split bg points, T=use all bg points
                      seed = 2) # set seed for random split
train <- split[[1]]
test <- split[[2]]

# prepare cross validation folds
k_max <- nrow(distinct(occurrence_coords, x, y)) - 1

cv_folds <- randomFolds(train, k = 3, only_presence = TRUE)

```
For data processing, the primary decision to be made was regarding the inclusion of background points. If `only_presence` is set to false, background points are split into test-train data along with the occurrences. If it's true, all the background points are used for model predictions. Background points are not equivalent to pseudoabsences, as they may occur in areas where the species is present. We want to set `only_presence` to TRUE, which is standard for presence-only methods.

__NOTE:__ Need to look into more `addSamplesToBg()`. Once the new layers were added, this had to be added in order to train the model.

### Tune Hyperparameters
```{r}
# define model
maxnet_model <- train(method = "Maxnet", 
                      folds = cv_folds,
                      data = train)

# select hyper parameters for testing
param_tune <- list(
  reg = seq(0.1, 3, 0.1), # regularization multiplier
  fc = c("lq", "lh", "lqp", "lqph", "lqpht")) # feature class combination

# remove variables with importance less than 2% IF it doesn't decrease model performance
maxnet_model_red <- reduceVar(maxnet_model,
                              th = 2,
                              metric = "auc",
                              test = test,
                              use_jk = TRUE)
```

__NOTE:__ Need to consider whether to use the Jackknife AUC test. When this is false, the percent contribution is used instead.

### Final Model
```{r}
# test possible combinations with gridSearch
gs <- gridSearch(maxnet_model_red, 
                 hypers = param_tune, 
                 metric = "auc", 
                 test = test)

# view top performing models
head(gs@results[order(-gs@results$test_AUC), ])  

# view parameters for best model
gs@models[[1]]

```


```{r, eval=FALSE}
map <- predict(maxnet_model_red,
               data = predictor_stack_rast,
               type = "cloglog")

# plot prediction map
tm_shape(map) +
  tm_raster(palette = "YlGnBu") +
  tm_shape(occurrences) +
  tm_dots(size = 0.15) +
  tm_layout(legend.position = c(1, 0.2))
```

## Fuction Testing
The previous steps were incorporated into a function that could iterate through all the plots. Given that the file structure remains the same, the only input required is a numeric plot number.
```{r}
rm(list = ls())

# wrangling
library(tidyverse)
library(here)
library(janitor)

# raster/geospatial
library(sf)
library(tmap)
library(terra)

# modeling
library(SDMtune)
library(rsample)
library(rJava)

# set data directory
output_dir <- here("data", "updated-rasters")
data_dir <- here("data", "CampRoberts_spatial_data")

# read occurences for plotting
occurrences <- st_read(here(data_dir, "Species_pts", "CR_BASP_obs_11Jul22.shp")) %>% 
  st_make_valid() %>% 
  clean_names() %>% 
  filter(plot == 4)

# source function
source(here("sdmtune-final-models", "sdmtune-maxent-final-function.R"))

# test function with plot
max_4 <- tune_maxent(4, data_dir, output_dir)
```

Isolate final best-fit model
```{r}
maxent_gs <- max_4[[4]]
maxent_test <- max_4[[2]]

# view top performing models
head(maxent_gs@results[order(-maxent_gs@results$test_AUC), ])  

# view parameters for best model
maxent_gs@models[[1]]

# isolate index location for the best parameters
best_locM <- which.max(maxent_gs@results$test_AUC)

# retrain model with best parameters for final prediction
best_modM <- combineCV(maxent_gs@models[[best_locM]])
```

Plots
```{r}
# plot AUC curves 
plotROC(best_modM, test = maxent_test)

# plot prediction raster
mapM <- predict(best_modM,
               data = predictor_stack_rast,
               type = "cloglog")

# plot prediction map
plotPred(mapM)

tm_shape(mapM) +
  tm_raster(palette = "BuPu") +
  tm_shape(occurrences) +
  tm_dots(size = 0.1) +
  tm_layout(legend.position = c(1, 0.2))
  
```



